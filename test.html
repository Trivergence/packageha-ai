<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Packageha AI - Flow Tester</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: #f5f5f5;
            min-height: 100vh;
            padding: 20px;
        }
        
        .container {
            max-width: 900px;
            margin: 0 auto;
            background: white;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
            overflow: hidden;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px 30px;
        }
        
        .header h1 {
            font-size: 24px;
            margin-bottom: 15px;
        }
        
        .config-section {
            display: flex;
            gap: 10px;
            align-items: center;
            margin-bottom: 15px;
        }
        
        .config-section input {
            flex: 1;
            padding: 8px 12px;
            border: none;
            border-radius: 6px;
            font-size: 14px;
            background: rgba(255,255,255,0.2);
            color: white;
        }
        
        .config-section input::placeholder {
            color: rgba(255,255,255,0.7);
        }
        
        .config-section button {
            padding: 8px 16px;
            background: white;
            color: #667eea;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            font-size: 14px;
            font-weight: 600;
        }
        
        .flow-selector {
            display: flex;
            gap: 10px;
            flex-wrap: wrap;
        }
        
        .flow-btn {
            padding: 6px 12px;
            border: 2px solid rgba(255,255,255,0.3);
            background: transparent;
            color: white;
            border-radius: 6px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }
        
        .flow-btn.active {
            background: white;
            color: #667eea;
            border-color: white;
        }
        
        .steps-container {
            padding: 30px;
        }
        
        .step-section {
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            margin-bottom: 15px;
            overflow: hidden;
            transition: all 0.3s;
        }
        
        .step-section.completed {
            border-color: #28a745;
            background: #f8fff9;
        }
        
        .step-section.active {
            border-color: #667eea;
            box-shadow: 0 4px 12px rgba(102, 126, 234, 0.2);
        }
        
        .step-header {
            padding: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: space-between;
            background: white;
            transition: background 0.2s;
        }
        
        .step-section.active .step-header {
            background: #f8f9ff;
        }
        
        .step-section.completed .step-header {
            background: #f8fff9;
        }
        
        .step-header:hover {
            background: #f5f5f5;
        }
        
        .step-title {
            display: flex;
            align-items: center;
            gap: 15px;
            flex: 1;
        }
        
        .step-number {
            width: 32px;
            height: 32px;
            border-radius: 50%;
            background: #e0e0e0;
            color: #666;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: 600;
            font-size: 14px;
            flex-shrink: 0;
        }
        
        .step-section.completed .step-number {
            background: #28a745;
            color: white;
        }
        
        .step-section.active .step-number {
            background: #667eea;
            color: white;
        }
        
        .step-info {
            flex: 1;
        }
        
        .step-name {
            font-weight: 600;
            font-size: 16px;
            color: #333;
            margin-bottom: 4px;
        }
        
        .step-detail {
            font-size: 13px;
            color: #666;
            font-style: italic;
        }
        
        .step-chevron {
            font-size: 20px;
            color: #999;
            transition: transform 0.3s;
        }
        
        .step-section.active .step-chevron {
            transform: rotate(180deg);
            color: #667eea;
        }
        
        .step-content {
            position: relative;
            max-height: 0;
            overflow: hidden;
            transition: max-height 0.3s ease-out;
        }
        
        .step-section.active .step-content {
            max-height: 2000px;
            transition: max-height 0.5s ease-in;
        }
        
        .step-body {
            padding: 0 20px 20px 20px;
            background: white;
        }
        
        .step-body.completed-view {
            padding: 20px;
            background: #f8fff9;
        }
        
        .answer-display {
            padding: 15px;
            background: white;
            border-radius: 6px;
            border-left: 4px solid #28a745;
            font-size: 15px;
            color: #333;
        }
        
        .completed-questions-section {
            background: #f8fff9;
            border: 1px solid #d4edda;
            border-radius: 8px;
            padding: 16px;
            margin-bottom: 20px;
        }
        
        .completed-question-item {
            padding: 12px;
            background: white;
            border-radius: 6px;
            margin-bottom: 10px;
            border-left: 3px solid #28a745;
        }
        
        .completed-question-item:last-child {
            margin-bottom: 0;
        }
        
        .checkbox-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 16px 0;
        }
        
        .checkbox-label {
            display: flex;
            align-items: center;
            padding: 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .checkbox-label:hover {
            border-color: #6c63ff;
            background: #f5f4ff;
        }
        
        .checkbox-label input[type="checkbox"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .checkbox-label input[type="checkbox"]:checked + span {
            font-weight: 600;
            color: #6c63ff;
        }
        
        .radio-group {
            display: flex;
            flex-direction: column;
            gap: 10px;
            margin: 16px 0;
        }
        
        .radio-label {
            display: flex;
            align-items: center;
            padding: 12px;
            background: white;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s;
            font-size: 14px;
        }
        
        .radio-label:hover {
            border-color: #6c63ff;
            background: #f5f4ff;
        }
        
        .radio-label input[type="radio"] {
            margin-right: 10px;
            width: 18px;
            height: 18px;
            cursor: pointer;
        }
        
        .radio-label input[type="radio"]:checked + span {
            font-weight: 600;
            color: #6c63ff;
        }
        
        .radio-label:has(input[type="radio"]:checked) {
            border-color: #6c63ff;
            background: #f5f4ff;
        }
        
        .loading-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(255, 255, 255, 0.9);
            display: none;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 100;
            border-radius: 8px;
        }
        
        .loading-spinner {
            width: 40px;
            height: 40px;
            border: 4px solid #f3f3f3;
            border-top: 4px solid #6c63ff;
            border-radius: 50%;
            animation: spin 1s linear infinite;
            margin-bottom: 12px;
        }
        
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
        
        .loading-text {
            color: #666;
            font-size: 14px;
            font-weight: 500;
        }
        
        .submit-btn:disabled {
            opacity: 0.6;
            cursor: not-allowed !important;
        }
        
        .question-text {
            font-size: 15px;
            color: #333;
            margin-bottom: 20px;
            font-weight: 500;
        }
        
        .options-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(200px, 1fr));
            gap: 12px;
            margin-bottom: 20px;
        }
        
        .option-card {
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 8px;
            cursor: pointer;
            text-align: center;
            transition: all 0.2s;
            background: white;
        }
        
        .option-card:hover {
            border-color: #667eea;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.2);
            transform: translateY(-2px);
        }
        
        .option-card.selected {
            border-color: #667eea;
            background: #f8f9ff;
        }
        
        .input-group {
            margin-bottom: 20px;
        }
        
        .input-group label {
            display: block;
            font-size: 13px;
            font-weight: 600;
            color: #666;
            margin-bottom: 8px;
        }
        
        .input-group input,
        .input-group textarea {
            width: 100%;
            padding: 12px;
            border: 2px solid #e0e0e0;
            border-radius: 6px;
            font-size: 14px;
            font-family: inherit;
            transition: border-color 0.2s;
        }
        
        .input-group input:focus,
        .input-group textarea:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .dimensions-row {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 12px;
        }
        
        .submit-btn {
            padding: 12px 24px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 6px;
            font-weight: 600;
            cursor: pointer;
            font-size: 14px;
            transition: background 0.2s;
        }
        
        .submit-btn:hover:not(:disabled) {
            background: #5568d3;
        }
        
        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
        }
        
        .draft-order-success {
            padding: 30px;
            text-align: center;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }
        
        .draft-order-success h2 {
            font-size: 24px;
            margin-bottom: 20px;
        }
        
        .draft-order-links {
            display: flex;
            gap: 15px;
            justify-content: center;
            flex-wrap: wrap;
        }
        
        .draft-order-links a {
            padding: 12px 24px;
            background: white;
            color: #667eea;
            text-decoration: none;
            border-radius: 8px;
            font-weight: 600;
            transition: all 0.2s;
        }
        
        .draft-order-links a:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px rgba(0,0,0,0.2);
        }
        
        @media (max-width: 768px) {
            .dimensions-row {
                grid-template-columns: 1fr;
            }
            
            .options-grid {
                grid-template-columns: 1fr;
            }
            
            .steps-container {
                padding: 15px;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ðŸ“¦ Packageha AI - Flow Tester</h1>
            <div class="config-section">
                <input type="text" id="apiUrl" placeholder="Worker URL" value="https://packageha-ai.akhodary-006.workers.dev">
                <button onclick="loadAvailableModels()">Check Models</button>
            </div>
            <!-- Flow selector removed - only direct_sales flow is supported -->
        </div>
        
        <div class="steps-container" id="stepsContainer">
            <!-- Steps will be dynamically generated -->
        </div>
    </div>
    
    <script>
        let currentFlow = 'direct_sales';
        let flowState = {
            productDetails: {}, // Product details answers
            package: null, // Package name
            variant: null, // Variant name
            packageSpecs: {}, // Package specifications (material, dimensions, print)
            fulfillmentSpecs: {}, // Fulfillment specifications
            launchKit: {}, // Launch kit services
            draftOrder: null, // Draft order result
            backendStep: null, // Track backend step for step completion logic
            previousBackendStep: null // Track previous backend step to detect transitions
        };
        let isLoading = false; // Track loading state
        
        const steps = [
            { id: 'product_details', name: 'Product Details', key: 'productDetails' },
            { id: 'package_selection', name: 'Package Selection', key: 'package' }, // Includes variant as substep
            { id: 'fulfillment_specs', name: 'Fulfilment Specs', key: 'fulfillmentSpecs' },
            { id: 'launch_kit', name: 'Launch Kit', key: 'launchKit' },
            { id: 'order', name: 'Draft Order', key: 'order' }
        ];
        
        function selectFlow(flow) {
            currentFlow = flow;
            document.querySelectorAll('.flow-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            document.querySelector(`[data-flow="${flow}"]`).classList.add('active');
            resetFlow();
        }
        
        function resetFlow() {
            flowState = {
                productDetails: {},
                package: null,
                variant: null,
                packageSpecs: {},
                fulfillmentSpecs: {},
                launchKit: {},
                draftOrder: null,
                backendStep: null,
                previousBackendStep: null
            };
            renderSteps();
        }
        
        function renderSteps() {
            const container = document.getElementById('stepsContainer');
            let html = '';
            
            steps.forEach((step, index) => {
                const isCompleted = isStepCompleted(step.id);
                const isActive = isStepActive(step.id);
                const stepData = getStepData(step.id);
                
                html += `
                    <div class="step-section ${isCompleted ? 'completed' : ''} ${isActive ? 'active' : ''}" data-step="${step.id}">
                        <div class="step-header" onclick="toggleStep('${step.id}')">
                            <div class="step-title">
                                <div class="step-number">${isCompleted ? 'âœ“' : (index + 1)}</div>
                                <div class="step-info">
                                    <div class="step-name">${step.name}</div>
                                    <div class="step-detail">${getStepDetail(step.id, stepData)}</div>
                                </div>
                            </div>
                            <div class="step-chevron">â–¼</div>
                        </div>
                        <div class="step-content">
                            ${isActive ? renderStepContent(step.id, stepData) : (isCompleted ? renderCompletedView(step.id, stepData) : '')}
                        </div>
                    </div>
                `;
            });
            
            container.innerHTML = html;
            
            // Expand active step and focus input
            steps.forEach(step => {
                const isActive = isStepActive(step.id);
                console.log(`[renderSteps] Step ${step.id} isActive:`, isActive);
                if (isActive) {
                    const stepEl = document.querySelector(`[data-step="${step.id}"]`);
                    if (stepEl) {
                        stepEl.classList.add('active');
                        console.log(`[renderSteps] Expanded step: ${step.id}`);
                        autoFocusInput(step.id);
                    }
                }
            });
        }
        
        function isStepCompleted(stepId) {
            if (stepId === 'product_details') {
                // Check if backend has moved past this step
                const backendStep = flowState.backendStep || '';
                if (backendStep === 'select_package' || backendStep === 'select_package_discovery' || 
                    backendStep === 'select_package_variant' || backendStep === 'select_package_specs' ||
                    backendStep === 'fulfillment_specs' || backendStep === 'launch_kit' || backendStep === 'draft_order') {
                    // Backend has moved past product_details, so it's completed
                    return true;
                }
                // Otherwise check if all required questions are answered
                const hasDescription = flowState.productDetails?.product_description;
                const hasBudget = flowState.productDetails?.budget;
                return hasDescription && hasBudget;
            }
            if (stepId === 'package_selection') {
                // Package selection is completed when package and variant are selected, and package specs are done
                return !!flowState.package && 
                       (!!flowState.variant || flowState.variant === 'Default') &&
                       Object.keys(flowState.packageSpecs || {}).length > 0;
            }
            if (stepId === 'fulfillment_specs') {
                return Object.keys(flowState.fulfillmentSpecs || {}).length > 0 && flowState.fulfillmentSpecs.quantity;
            }
            if (stepId === 'launch_kit') {
                // Launch kit is optional, so it's completed if answered or if we moved to order
                return flowState.draftOrder || Object.keys(flowState.launchKit || {}).length > 0;
            }
            if (stepId === 'order') return !!flowState.draftOrder;
            return false;
        }
        
        function isStepActive(stepId) {
            const result = (() => {
                if (flowState.draftOrder) return stepId === 'order';
                
                // Determine which step should be active based on completion state
                if (!isStepCompleted('product_details')) return stepId === 'product_details';
                if (!isStepCompleted('package_selection')) return stepId === 'package_selection';
                if (!isStepCompleted('fulfillment_specs')) return stepId === 'fulfillment_specs';
                if (!isStepCompleted('launch_kit')) return stepId === 'launch_kit';
                
                return stepId === 'order';
            })();
            console.log(`[isStepActive] ${stepId}:`, result, 'flowState:', flowState);
            return result;
        }
        
        function getStepData(stepId) {
            if (stepId === 'product_details') return flowState.productDetailsData;
            if (stepId === 'package_selection') {
                // Package selection step can show either packageData (for product search/selection)
                // or packageSpecsData (for package specs questions)
                // Prefer packageSpecsData if it has a currentQuestion, otherwise use packageData
                if (flowState.packageSpecsData && flowState.packageSpecsData.currentQuestion) {
                    return flowState.packageSpecsData;
                }
                return flowState.packageData;
            }
            if (stepId === 'fulfillment_specs') return flowState.fulfillmentSpecsData;
            if (stepId === 'launch_kit') return flowState.launchKitData;
            return null;
        }
        
        function getStepDetail(stepId, stepData) {
            if (stepId === 'product_details') {
                const count = Object.keys(flowState.productDetails || {}).filter(k => flowState.productDetails[k] && flowState.productDetails[k] !== 'undefined').length;
                return count > 0 ? `${count} question(s) answered` : 'Pending';
            }
            if (stepId === 'package_selection') {
                if (flowState.package) {
                    let detail = flowState.package;
                    if (flowState.variant && flowState.variant !== 'Default') {
                        detail += ' | Variant: ' + flowState.variant;
                    } else if (flowState.variant === 'Default') {
                        detail += ' | Default';
                    }
                    const specsCount = Object.keys(flowState.packageSpecs || {}).length;
                    if (specsCount > 0) detail += ` | ${specsCount} spec(s)`;
                    return detail;
                }
                return 'Pending';
            }
            if (stepId === 'fulfillment_specs') {
                const count = Object.keys(flowState.fulfillmentSpecs || {}).filter(k => flowState.fulfillmentSpecs[k] && flowState.fulfillmentSpecs[k] !== 'undefined').length;
                return count > 0 ? `${count} question(s) answered` : 'Pending';
            }
            if (stepId === 'launch_kit') {
                const count = Object.keys(flowState.launchKit || {}).filter(k => flowState.launchKit[k] && flowState.launchKit[k] !== 'undefined').length;
                return count > 0 ? `${count} question(s) answered` : 'Pending';
            }
            if (stepId === 'order' && flowState.draftOrder) return 'Order created successfully';
            return 'Pending';
        }
        
        function toggleStep(stepId) {
            const stepEl = document.querySelector(`[data-step="${stepId}"]`);
            if (stepEl) {
                stepEl.classList.toggle('active');
            }
        }
        
        function renderStepContent(stepId, stepData) {
            // Product Details step
            if (stepId === 'product_details') {
                return renderConsultationStep('product_details', flowState.productDetails, stepData);
            }
            
            // Package Selection step
            if (stepId === 'package_selection') {
                // If we have package specs question, render that instead
                if (flowState.packageSpecsData && flowState.packageSpecsData.currentQuestion) {
                    return renderConsultationStep('package_specs', flowState.packageSpecs, flowState.packageSpecsData);
                }
                // Otherwise show product search/selection
                if (stepData && stepData.matches) {
                    return renderProductSelection(stepData.matches);
                }
                return renderProductSearch();
            }
            
            // Fulfillment Specs step
            if (stepId === 'fulfillment_specs') {
                return renderConsultationStep('fulfillment_specs', flowState.fulfillmentSpecs, stepData);
            }
            
            // Launch Kit step
            if (stepId === 'launch_kit') {
                return renderConsultationStep('launch_kit', flowState.launchKit, stepData);
            }
            
            // Order step
            if (stepId === 'order') {
                if (flowState.draftOrder) {
                    return renderDraftOrder(flowState.draftOrder);
                }
                return '<div class="step-body"><p>Generating draft order...</p></div>';
            }
            return '';
        }
        
        // Helper function to render consultation-style steps
        function renderConsultationStep(stepId, answers, stepData) {
            console.log(`[renderConsultationStep] ${stepId} stepData:`, stepData);
            let html = '';
            
            // Show completed questions first
            if (answers && Object.keys(answers).length > 0) {
                html += '<div class="completed-questions-section">';
                html += '<div style="font-weight: 600; margin-bottom: 12px; color: #28a745;">âœ“ Completed Questions:</div>';
                Object.entries(answers).forEach(([questionId, answer]) => {
                    if (answer && answer !== 'undefined' && answer !== undefined) {
                        html += `<div class="completed-question-item">
                            <div style="font-weight: 500; color: #666; font-size: 14px; margin-bottom: 4px;">${getQuestionLabel(questionId)}</div>
                            <div style="color: #333;">${answer}</div>
                        </div>`;
                    }
                });
                html += '</div>';
            }
            
            // Show current question
            if (stepData && stepData.currentQuestion) {
                console.log(`[renderConsultationStep] Rendering question for ${stepId}:`, stepData.currentQuestion);
                html += renderQuestion(stepData.currentQuestion);
            } else {
                console.log(`[renderConsultationStep] No currentQuestion in stepData for ${stepId}, showing loading`);
                html += '<div class="step-body"><p>Loading question...</p></div>';
            }
            
            return html;
        }
        
        function renderCompletedView(stepId, stepData) {
            if (stepId === 'product_details' && flowState.productDetails) {
                let html = '<div class="step-body completed-view">';
                Object.entries(flowState.productDetails).forEach(([key, value]) => {
                    if (value && value !== 'undefined') {
                        html += `<div class="answer-display" style="margin-bottom: 10px;"><strong>${getQuestionLabel(key)}:</strong> ${value}</div>`;
                    }
                });
                html += '</div>';
                return html;
            }
            if (stepId === 'package_selection' && flowState.package) {
                let html = `<div class="step-body completed-view">
                    <div class="answer-display"><strong>Package:</strong> ${flowState.package}</div>`;
                if (flowState.variant) {
                    html += `<div class="answer-display" style="margin-top: 10px;"><strong>Variant:</strong> ${flowState.variant === 'Default' ? 'Default' : flowState.variant}</div>`;
                }
                if (flowState.packageSpecs && Object.keys(flowState.packageSpecs).length > 0) {
                    Object.entries(flowState.packageSpecs).forEach(([key, value]) => {
                        if (value && value !== 'undefined') {
                            html += `<div class="answer-display" style="margin-top: 10px;"><strong>${getQuestionLabel(key)}:</strong> ${value}</div>`;
                        }
                    });
                }
                html += '</div>';
                return html;
            }
            if (stepId === 'fulfillment_specs' && flowState.fulfillmentSpecs) {
                let html = '<div class="step-body completed-view">';
                Object.entries(flowState.fulfillmentSpecs).forEach(([key, value]) => {
                    if (value && value !== 'undefined') {
                        html += `<div class="answer-display" style="margin-bottom: 10px;"><strong>${getQuestionLabel(key)}:</strong> ${value}</div>`;
                    }
                });
                html += '</div>';
                return html;
            }
            if (stepId === 'launch_kit' && flowState.launchKit) {
                let html = '<div class="step-body completed-view">';
                Object.entries(flowState.launchKit).forEach(([key, value]) => {
                    if (value && value !== 'undefined') {
                        html += `<div class="answer-display" style="margin-bottom: 10px;"><strong>${getQuestionLabel(key)}:</strong> ${value}</div>`;
                    }
                });
                html += '</div>';
                return html;
            }
            return '';
        }
        
        function renderProductSearch() {
            // Generate suggested search query based on product details
            let suggestedQuery = '';
            if (flowState.productDetails) {
                const parts = [];
                if (flowState.productDetails.product_description) {
                    // Extract key terms from product description
                    const desc = flowState.productDetails.product_description.toLowerCase();
                    if (desc.includes('fragile') || (flowState.productDetails.fragility && flowState.productDetails.fragility.includes('fragile'))) {
                        parts.push('protective');
                    }
                    if (desc.includes('food') || desc.includes('edible')) {
                        parts.push('food-safe');
                    }
                    if (desc.includes('electronic') || desc.includes('device')) {
                        parts.push('electronics packaging');
                    }
                }
                if (flowState.productDetails.product_dimensions) {
                    parts.push(flowState.productDetails.product_dimensions);
                }
                if (flowState.productDetails.fragility && flowState.productDetails.fragility.includes('cushioning')) {
                    parts.push('cushioned box');
                }
                if (parts.length > 0) {
                    suggestedQuery = parts.join(' ');
                } else {
                    suggestedQuery = 'custom box';
                }
            }
            
            return `
                <div class="step-body">
                    <div class="question-text">What package are you looking for?</div>
                    <div class="input-group">
                        <input type="text" id="productSearchInput" placeholder="e.g., Custom Boxes, Bags, Printing Services..." 
                               value="${suggestedQuery}"
                               onkeydown="if(event.key==='Enter') searchProducts()">
                    </div>
                    <button class="submit-btn" onclick="searchProducts()">Search Packages</button>
                    <div id="searchFallbackMessage" style="display: none; margin-top: 12px; padding: 12px; background-color: #fff3cd; border: 1px solid #ffc107; border-radius: 4px; color: #856404;">
                        No packages found. Try a simpler search like "box" or "packaging".
                    </div>
                </div>
            `;
        }
        
        function searchProductsWithFallback() {
            const input = document.getElementById('productSearchInput');
            if (input && input.value.trim()) {
                const query = input.value.trim();
                sendSelection(query, { type: 'product_search', originalQuery: query });
            } else {
                // If empty, send a generic search
                sendSelection('show me products', { type: 'product_search' });
            }
        }
        
        function renderProductSelection(matches) {
            let html = '<div class="step-body"><div class="question-text">Select a product:</div><div class="options-grid">';
            matches.forEach((match, index) => {
                html += `
                    <div class="option-card" onclick="selectProduct(${index}, '${match.name.replace(/'/g, "\\'")}')">
                        <div style="font-weight: 600; margin-bottom: 8px;">${match.name}</div>
                        <div style="font-size: 12px; color: #666;">${match.reason}</div>
                    </div>
                `;
            });
            html += '</div></div>';
            return html;
        }
        
        function renderVariantSelection(variants) {
            let html = '<div class="step-body"><div class="question-text">Select a variant:</div><div class="options-grid">';
            variants.forEach((variant, index) => {
                html += `
                    <div class="option-card" onclick="selectVariant(${index}, '${variant.title.replace(/'/g, "\\'")}', ${variant.id})">
                        <div style="font-weight: 600; margin-bottom: 8px;">${variant.title}</div>
                        <div style="font-size: 12px; color: #666;">Price: ${variant.price}</div>
                    </div>
                `;
            });
            html += '</div></div>';
            return html;
        }
        
        function getQuestionLabel(questionId) {
            const labels = {
                // Product Details
                'product_description': 'Product Description',
                'product_dimensions': 'Product Dimensions',
                'product_weight': 'Product Weight',
                'fragility': 'Fragility',
                'budget': 'Budget',
                // Package Specs
                'material': 'Material',
                'dimensions': 'Package Dimensions',
                'print': 'Printing/Finish',
                // Fulfillment Specs
                'quantity': 'Quantity',
                'timeline': 'Timeline',
                'shipping_address': 'Shipping Address',
                'special_instructions': 'Special Instructions',
                // Launch Kit
                'service_selection': 'Services',
                'service_timeline': 'Service Timeline',
                'service_notes': 'Service Notes'
            };
            return labels[questionId] || questionId.replace(/_/g, ' ').replace(/\b\w/g, l => l.toUpperCase());
        }
        
        function renderQuestion(question) {
            let html = '<div class="step-body"><div class="question-text">' + question.question + '</div>';
            
            if (question.options && question.options.length > 0) {
                const isMultiple = question.multiple !== false; // Default to true (checkboxes) unless explicitly false
                const isGrouped = question.multiple === "grouped";
                
                if (isGrouped && Array.isArray(question.options) && question.options.length > 0 && Array.isArray(question.options[0])) {
                    // Grouped mode: first group is radio buttons, rest are checkboxes
                    html += '<div id="option-group-' + question.id + '">';
                    
                    // First group: mutually exclusive (radio buttons)
                    if (question.options[0] && question.options[0].length > 0) {
                        html += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; margin-bottom: 12px; color: #666;">Printing Type (choose one):</div>';
                        html += '<div class="radio-group" id="radio-group-' + question.id + '">';
                        question.options[0].forEach((option, index) => {
                            html += `
                                <label class="radio-label">
                                    <input type="radio" name="radio-${question.id}" value="${String(option).replace(/"/g, '&quot;')}" 
                                           id="radio-${question.id}-${index}">
                                    <span>${option}</span>
                                </label>
                            `;
                        });
                        html += '</div></div>';
                    }
                    
                    // Second group: combinable options (checkboxes)
                    if (question.options[1] && question.options[1].length > 0) {
                        // Further split: lamination is mutually exclusive, others can combine
                        const laminationOptions = [];
                        const otherOptions = [];
                        question.options[1].forEach(opt => {
                            if (opt.includes('lamination')) {
                                laminationOptions.push(opt);
                            } else {
                                otherOptions.push(opt);
                            }
                        });
                        
                        // Lamination options as radio (mutually exclusive)
                        if (laminationOptions.length > 0) {
                            html += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; margin-bottom: 12px; color: #666;">Lamination (choose one):</div>';
                            html += '<div class="radio-group" id="lamination-radio-' + question.id + '">';
                            laminationOptions.forEach((option, index) => {
                                html += `
                                    <label class="radio-label">
                                        <input type="radio" name="lamination-radio-${question.id}" value="${String(option).replace(/"/g, '&quot;')}" 
                                               id="lamination-${question.id}-${index}">
                                        <span>${option}</span>
                                    </label>
                                `;
                            });
                            html += '</div></div>';
                        }
                        
                        // Other options as checkboxes (can combine)
                        if (otherOptions.length > 0) {
                            html += '<div style="margin-bottom: 20px;"><div style="font-weight: 600; margin-bottom: 12px; color: #666;">Additional Finishing (select all that apply):</div>';
                            html += '<div class="checkbox-group" id="checkbox-group-' + question.id + '">';
                            otherOptions.forEach((option, index) => {
                                html += `
                                    <label class="checkbox-label">
                                        <input type="checkbox" value="${String(option).replace(/"/g, '&quot;')}" 
                                               id="checkbox-${question.id}-${index}">
                                        <span>${option}</span>
                                    </label>
                                `;
                            });
                            html += '</div></div>';
                        }
                    }
                    
                    html += '</div>';
                    
                    // Additional notes field
                    html += `
                        <div class="input-group" style="margin-top: 16px;">
                            <label style="display: block; margin-bottom: 6px; font-weight: 500; color: #666;">Additional notes (optional):</label>
                            <input type="text" id="notes-${question.id}" placeholder="Any additional details or custom requirements...">
                        </div>
                        <button class="submit-btn" onclick="submitGroupedAnswer('${question.id}')">Submit</button>
                    `;
                } else if (isMultiple) {
                    // Render as checkboxes with notes field (for multiple selections)
                    html += '<div class="checkbox-group" id="option-group-' + question.id + '">';
                    question.options.forEach((option, index) => {
                        html += `
                            <label class="checkbox-label">
                                <input type="checkbox" value="${String(option).replace(/"/g, '&quot;')}" 
                                       id="option-${question.id}-${index}">
                                <span>${option}</span>
                            </label>
                        `;
                    });
                    html += '</div>';
                    
                    // Additional notes field
                    html += `
                        <div class="input-group" style="margin-top: 16px;">
                            <label style="display: block; margin-bottom: 6px; font-weight: 500; color: #666;">Additional notes (optional):</label>
                            <input type="text" id="notes-${question.id}" placeholder="Any additional details or custom requirements...">
                        </div>
                        <button class="submit-btn" onclick="submitCheckboxAnswer('${question.id}')">Submit</button>
                    `;
                } else {
                    // Render as radio buttons (single selection)
                    html += '<div class="radio-group" id="option-group-' + question.id + '">';
                    question.options.forEach((option, index) => {
                        html += `
                            <label class="radio-label">
                                <input type="radio" name="radio-${question.id}" value="${String(option).replace(/"/g, '&quot;')}" 
                                       id="option-${question.id}-${index}">
                                <span>${option}</span>
                            </label>
                        `;
                    });
                    html += '</div>';
                    
                    // Additional notes field
                    html += `
                        <div class="input-group" style="margin-top: 16px;">
                            <label style="display: block; margin-bottom: 6px; font-weight: 500; color: #666;">Additional notes (optional):</label>
                            <input type="text" id="notes-${question.id}" placeholder="Any additional details or custom requirements...">
                        </div>
                        <button class="submit-btn" onclick="submitRadioAnswer('${question.id}')">Submit</button>
                    `;
                }
            } else {
                // Render as input field(s)
                if (question.id === 'dimensions' || question.id === 'product_dimensions') {
                    // Special handling for dimensions - 3 separate inputs
                    html += `
                        <div class="dimensions-row">
                            <div class="input-group">
                                <label>Length</label>
                                <input type="text" id="dim_length" placeholder="e.g., 20 cm">
                            </div>
                            <div class="input-group">
                                <label>Width</label>
                                <input type="text" id="dim_width" placeholder="e.g., 15 cm">
                            </div>
                            <div class="input-group">
                                <label>Height</label>
                                <input type="text" id="dim_height" placeholder="e.g., 10 cm">
                            </div>
                        </div>
                        <button class="submit-btn" onclick="submitDimensions('${question.id}')">Submit</button>
                    `;
                } else if (question.id === 'quantity') {
                    // Number input for quantity
                    html += `
                        <div class="input-group">
                            <input type="number" id="questionInput" value="${question.defaultValue || '1'}" min="1" placeholder="Enter quantity">
                        </div>
                        <button class="submit-btn" onclick="submitAnswer('${question.id}')">Submit</button>
                    `;
                } else {
                    // Regular text input
                    html += `
                        <div class="input-group">
                            <input type="text" id="questionInput" value="${question.defaultValue || ''}" placeholder="Enter your answer...">
                        </div>
                        <button class="submit-btn" onclick="submitAnswer('${question.id}')">Submit</button>
                    `;
                }
            }
            
            html += '</div>';
            return html;
        }
        
        function renderDraftOrder(draftOrder) {
            return `
                <div class="draft-order-success">
                    <h2>âœ… Draft Order Created!</h2>
                    <div class="draft-order-links">
                        ${draftOrder.adminUrl ? `<a href="${draftOrder.adminUrl}" target="_blank">ðŸ“‹ View Draft Order</a>` : ''}
                        ${draftOrder.invoiceUrl ? `<a href="${draftOrder.invoiceUrl}" target="_blank">ðŸ’³ View Invoice & Pay</a>` : ''}
                    </div>
                </div>
            `;
        }
        
        function searchProducts() {
            const input = document.getElementById('productSearchInput');
            if (input && input.value.trim()) {
                const query = input.value.trim();
                sendSelection(query, { type: 'product_search', originalQuery: query });
            } else {
                // If empty, send a generic search
                sendSelection('show me products', { type: 'product_search' });
            }
        }
        
        function selectProduct(index, name) {
            console.log('[selectProduct] Product selected:', { index, name });
            sendSelection(String(index + 1), { type: 'product', name });
        }
        
        function selectVariant(index, title, id) {
            console.log('[selectVariant] Variant selected:', { index, title, id });
            sendSelection(title, { type: 'variant', title, id });
        }
        
        function selectOption(option, questionId) {
            sendSelection(option, { type: 'option', questionId, option });
        }
        
        function submitCheckboxAnswer(questionId) {
            const checkboxes = document.querySelectorAll(`#option-group-${questionId} input[type="checkbox"]:checked`);
            const notesInput = document.getElementById(`notes-${questionId}`);
            const notes = notesInput ? notesInput.value.trim() : '';
            
            const selectedOptions = Array.from(checkboxes).map(cb => cb.value);
            
            if (selectedOptions.length === 0 && !notes) {
                alert('Please select at least one option or add notes.');
                return;
            }
            
            let answer = selectedOptions.join(', ');
            if (notes) {
                answer += (answer ? ' | Notes: ' : 'Notes: ') + notes;
            }
            
            sendSelection(answer, { type: 'answer', questionId, answer: answer });
        }
        
        function submitRadioAnswer(questionId) {
            const radio = document.querySelector(`#option-group-${questionId} input[type="radio"]:checked`);
            const notesInput = document.getElementById(`notes-${questionId}`);
            const notes = notesInput ? notesInput.value.trim() : '';
            
            if (!radio && !notes) {
                alert('Please select an option or add notes.');
                return;
            }
            
            let answer = radio ? radio.value : '';
            if (notes) {
                answer += (answer ? ' | Notes: ' : 'Notes: ') + notes;
            }
            
            sendSelection(answer, { type: 'answer', questionId, answer: answer });
        }
        
        function submitGroupedAnswer(questionId) {
            // Get printing type (radio)
            const printingRadio = document.querySelector(`#radio-group-${questionId} input[type="radio"]:checked`);
            // Get lamination (radio)
            const laminationRadio = document.querySelector(`#lamination-radio-${questionId} input[type="radio"]:checked`);
            // Get additional finishing (checkboxes)
            const checkboxes = document.querySelectorAll(`#checkbox-group-${questionId} input[type="checkbox"]:checked`);
            const notesInput = document.getElementById(`notes-${questionId}`);
            const notes = notesInput ? notesInput.value.trim() : '';
            
            const selectedOptions = [];
            if (printingRadio) selectedOptions.push(printingRadio.value);
            if (laminationRadio) selectedOptions.push(laminationRadio.value);
            Array.from(checkboxes).forEach(cb => selectedOptions.push(cb.value));
            
            if (selectedOptions.length === 0 && !notes) {
                alert('Please select at least one option or add notes.');
                return;
            }
            
            let answer = selectedOptions.join(', ');
            if (notes) {
                answer += (answer ? ' | Notes: ' : 'Notes: ') + notes;
            }
            
            sendSelection(answer, { type: 'answer', questionId, answer: answer });
        }
        
        function submitAnswer(questionId) {
            const input = document.getElementById('questionInput');
            if (input && input.value.trim()) {
                const answer = input.value.trim();
                sendSelection(answer, { type: 'answer', questionId, answer: answer });
            }
        }
        
        function submitDimensions(questionId) {
            const length = document.getElementById('dim_length')?.value.trim() || '';
            const width = document.getElementById('dim_width')?.value.trim() || '';
            const height = document.getElementById('dim_height')?.value.trim() || '';
            
            if (!length || !width || !height) {
                alert('Please fill in all dimension fields (Length, Width, and Height)');
                return;
            }
            
            const dimensions = `${length} x ${width} x ${height}`;
            sendSelection(dimensions, { type: 'answer', questionId, answer: dimensions });
        }
        
        // Auto-focus input when step becomes active
        function autoFocusInput(stepId) {
            setTimeout(() => {
                if (stepId === 'package_selection') {
                    const input = document.getElementById('productSearchInput');
                    if (input) input.focus();
                } else {
                    const input = document.getElementById('questionInput');
                    if (input) input.focus();
                }
            }, 100);
        }
        
        async function sendSelection(message, metadata) {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            if (!apiUrl) {
                console.error('[sendSelection] No API URL provided');
                return;
            }
            
            // Prevent multiple simultaneous requests
            if (isLoading) {
                console.log('[sendSelection] Already loading, ignoring request');
                return;
            }
            
            isLoading = true;
            updateLoadingState(true, metadata);
            
            // Ensure metadata includes the message for answer extraction
            if (metadata && !metadata.message) {
                metadata.message = message;
            }
            
            console.log('[sendSelection] Sending request:', { message, metadata, flow: currentFlow });
            
            try {
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message, flow: currentFlow })
                });
                
                console.log('[sendSelection] Response status:', response.status);
                
                if (!response.ok) {
                    const errorText = await response.text();
                    console.error('[sendSelection] Response error:', errorText);
                    throw new Error(`HTTP ${response.status}: ${errorText}`);
                }
                
                const data = await response.json();
                console.log('[sendSelection] Response data:', data);
                console.log('[sendSelection] productMatches in response:', data.productMatches ? `${data.productMatches.length} matches` : 'none');
                
                handleResponse(data, metadata);
            } catch (error) {
                console.error('[sendSelection] Error:', error);
                alert(`Error: ${error.message}`);
            } finally {
                isLoading = false;
                updateLoadingState(false);
            }
        }
        
        function updateLoadingState(loading, metadata) {
            isLoading = loading;
            
            // Disable/enable all submit buttons
            document.querySelectorAll('.submit-btn').forEach(btn => {
                btn.disabled = loading;
                if (loading) {
                    btn.style.opacity = '0.6';
                    btn.style.cursor = 'not-allowed';
                } else {
                    btn.style.opacity = '1';
                    btn.style.cursor = 'pointer';
                }
            });
            
            // Show/hide loading indicator in the active step
            if (loading) {
                showLoadingIndicator(metadata);
            } else {
                hideLoadingIndicator();
            }
        }
        
        function showLoadingIndicator(metadata) {
            // Determine which step is loading based on metadata
            let stepId = 'fulfillment_specs'; // default
            if (metadata) {
                if (metadata.type === 'product_search' || metadata.type === 'product') {
                    stepId = 'package_selection';
                } else if (metadata.type === 'variant') {
                    stepId = 'package_selection'; // variant is part of package selection step now
                } else if (metadata.type === 'answer' || metadata.type === 'option') {
                    // Default to fulfillment_specs, but this will be determined by backend step in handleResponse
                    stepId = 'fulfillment_specs';
                }
            }
            
            const stepEl = document.querySelector(`[data-step="${stepId}"]`);
            if (stepEl) {
                // Check if step content area exists
                const contentEl = stepEl.querySelector('.step-content');
                if (contentEl) {
                    // Add loading overlay
                    let loader = contentEl.querySelector('.loading-overlay');
                    if (!loader) {
                        loader = document.createElement('div');
                        loader.className = 'loading-overlay';
                        loader.innerHTML = `
                            <div class="loading-spinner"></div>
                            <div class="loading-text">Processing...</div>
                        `;
                        contentEl.appendChild(loader);
                    }
                    loader.style.display = 'flex';
                }
            }
        }
        
        function hideLoadingIndicator() {
            document.querySelectorAll('.loading-overlay').forEach(overlay => {
                overlay.style.display = 'none';
            });
        }
        
        // Helper function to get the current consultation state property based on backend step
        function getCurrentConsultationState(backendStep) {
            if (backendStep === 'product_details') return 'productDetails';
            if (backendStep === 'select_package_specs') return 'packageSpecs';
            if (backendStep === 'fulfillment_specs') return 'fulfillmentSpecs';
            if (backendStep === 'launch_kit') return 'launchKit';
            // Default to fulfillment_specs for backward compatibility
            return 'fulfillmentSpecs';
        }
        
        function handleResponse(data, metadata) {
            console.log('[handleResponse] Called with:', { data, metadata });
            console.log('[handleResponse] Response data.productMatches:', data.productMatches ? `${data.productMatches.length} matches` : 'none');
            console.log('[handleResponse] Current flowState:', JSON.parse(JSON.stringify(flowState)));
            console.log('[handleResponse] Response data.flowState:', data.flowState);
            console.log('[handleResponse] Response data.currentQuestion:', data.currentQuestion ? 'present' : 'missing');
            console.log('[handleResponse] Response data.variants:', data.variants ? `${data.variants.length} variants` : 'none');
            
            const backendStep = data.flowState?.step || '';
            // Store the message from metadata for answer extraction (fallback)
            const messageFromMetadata = metadata && metadata.message ? metadata.message : null;
            
            // Store backend step in flowState early so other logic can use it
            flowState.backendStep = backendStep;
            
            // CRITICAL: Check for variant auto-skip FIRST (before any other logic)
            // If backend is in package specs (currentQuestion present) but no variant is selected,
            // it means variant step was auto-skipped (single variant or no variants)
            if (data.currentQuestion && !flowState.variant && flowState.package && backendStep === 'select_package_specs') {
                console.log('[handleResponse] CRITICAL: Detecting variant auto-skip - currentQuestion present but no variant');
                if (data.flowState && data.flowState.hasVariant && data.flowState.variantName) {
                    console.log('[handleResponse] Setting variant from flowState.variantName:', data.flowState.variantName);
                    flowState.variant = data.flowState.variantName;
                } else {
                    console.log('[handleResponse] No variant name in flowState - using "Default"');
                    flowState.variant = 'Default';
                }
                flowState.packageData = null; // Clear package data since we're auto-completing
            }
            
            // Handle package search - show matches
            // IMPORTANT: Don't return early - continue processing to update backend step
            if (metadata && metadata.type === 'product_search') {
                console.log('[handleResponse] Handling product_search, backendStep:', backendStep);
                // Ensure we're in package selection step state
                if (backendStep !== 'select_package' && backendStep !== 'select_package_discovery' && backendStep !== 'select_package_variant') {
                    console.log('[handleResponse] WARNING: product_search but backendStep is', backendStep, '- this might cause issues');
                }
                
                if (data.productMatches && data.productMatches.length > 0) {
                    console.log('[handleResponse] Found package matches:', data.productMatches.length);
                    flowState.packageData = flowState.packageData || {};
                    flowState.packageData.matches = data.productMatches;
                    console.log('[handleResponse] Set flowState.packageData.matches:', flowState.packageData);
                    // Hide fallback message if matches found
                    const fallbackMsg = document.getElementById('searchFallbackMessage');
                    if (fallbackMsg) fallbackMsg.style.display = 'none';
                    // Continue processing - don't return early
                } else if (data.flowState && data.flowState.hasPackage) {
                    // If no matches but we have a reply, the package was found directly
                    console.log('[handleResponse] Package found directly:', data.flowState.packageName);
                    flowState.package = data.flowState.packageName;
                    flowState.packageData = null;
                    // Hide fallback message
                    const fallbackMsg = document.getElementById('searchFallbackMessage');
                    if (fallbackMsg) fallbackMsg.style.display = 'none';
                    
                    // Check if variant was auto-skipped immediately after package selection
                    if (data.currentQuestion && backendStep === 'select_package_specs') {
                        console.log('[handleResponse] Package found and variant auto-skipped (currentQuestion present)');
                        flowState.variant = data.flowState?.variantName || 'Default';
                        flowState.packageData = null;
                        
                        // CRITICAL: Set packageSpecsData
                        if (!flowState.packageSpecsData) {
                            flowState.packageSpecsData = {};
                        }
                        flowState.packageSpecsData.currentQuestion = data.currentQuestion;
                        console.log('[handleResponse] Set packageSpecsData in product_search handler:', flowState.packageSpecsData);
                    }
                    // Continue processing - don't return early
                } else {
                    // No matches found - show fallback message
                    console.log('[handleResponse] No productMatches and no hasPackage - search returned no results');
                    const fallbackMsg = document.getElementById('searchFallbackMessage');
                    if (fallbackMsg) {
                        fallbackMsg.style.display = 'block';
                    }
                }
            }
            
            // Update flow state based on metadata and response
            if (metadata && metadata.type === 'product' && data.flowState && data.flowState.hasPackage) {
                console.log('[handleResponse] Package selected:', data.flowState.packageName);
                flowState.package = data.flowState.packageName || metadata.name;
                flowState.packageData = null;
                
                // CRITICAL: When product is selected and backend moved to select_package_specs, 
                // we need to clear package selection and set packageSpecsData
                if (backendStep === 'select_package_specs') {
                    console.log('[handleResponse] Package selected - backend moved to select_package_specs');
                    flowState.variant = data.flowState?.variantName || 'Default';
                    flowState.packageData = null;
                    
                    // Set packageSpecsData with currentQuestion
                    if (!flowState.packageSpecsData) {
                        flowState.packageSpecsData = {};
                    }
                    if (data.currentQuestion) {
                        flowState.packageSpecsData.currentQuestion = data.currentQuestion;
                        console.log('[handleResponse] Set packageSpecsData.currentQuestion:', data.currentQuestion);
                    }
                } else if (data.flowState.hasVariant && data.flowState.variantName) {
                    console.log('[handleResponse] Variant auto-selected (single variant):', data.flowState.variantName);
                    flowState.variant = data.flowState.variantName;
                    flowState.packageData = null;
                }
            }
            
            if (metadata && metadata.type === 'variant' && data.flowState && data.flowState.hasVariant) {
                console.log('[handleResponse] Variant selected:', data.flowState.variantName);
                flowState.variant = data.flowState.variantName || metadata.title;
                flowState.packageData = null;
            }
            
            // Store answers in the appropriate consultation state based on questionId
            // We can't rely on backendStep because it may have changed after processing the answer
            if (metadata && (metadata.type === 'answer' || metadata.type === 'option')) {
                console.log('[handleResponse] Answer/option recorded:', metadata.questionId, metadata.answer || metadata.option || metadata.message);
                // Determine which consultation phase this question belongs to based on questionId
                let consultationKey = 'fulfillmentSpecs'; // default
                if (metadata.questionId && (
                    metadata.questionId === 'product_description' ||
                    metadata.questionId === 'product_dimensions' ||
                    metadata.questionId === 'product_weight' ||
                    metadata.questionId === 'fragility' ||
                    metadata.questionId === 'budget'
                )) {
                    consultationKey = 'productDetails';
                } else if (metadata.questionId && (
                    metadata.questionId === 'material' ||
                    metadata.questionId === 'dimensions' ||
                    metadata.questionId === 'print'
                )) {
                    consultationKey = 'packageSpecs';
                } else if (metadata.questionId && (
                    metadata.questionId === 'service_selection' ||
                    metadata.questionId === 'service_timeline' ||
                    metadata.questionId === 'service_notes'
                )) {
                    consultationKey = 'launchKit';
                }
                
                if (!flowState[consultationKey]) flowState[consultationKey] = {};
                // Get answer value - prioritize metadata.answer, then metadata.option, then metadata.message
                const answerValue = metadata.answer || metadata.option || metadata.message || messageFromMetadata;
                if (answerValue && answerValue !== 'undefined' && answerValue !== 'null' && answerValue.trim() !== '') {
                    flowState[consultationKey][metadata.questionId] = answerValue;
                    console.log(`[handleResponse] Stored answer in ${consultationKey}[${metadata.questionId}] = ${answerValue}`);
                } else {
                    console.warn(`[handleResponse] Could not extract answer value for ${metadata.questionId} from metadata:`, metadata, 'messageFromMetadata:', messageFromMetadata);
                }
            }
            
            // Update step data - handle productMatches and variants
            // NOTE: This should happen AFTER product_search handler, but we check here too for safety
            if (data.productMatches) {
                console.log('[handleResponse] Updating productMatches (general handler):', data.productMatches.length);
                flowState.packageData = flowState.packageData || {};
                flowState.packageData.matches = data.productMatches;
            }
            if (data.variants) {
                console.log('[handleResponse] Updating variants:', data.variants.length, data.variants);
                flowState.packageData = flowState.packageData || {};
                flowState.packageData.variants = data.variants;
            }
            // Handle step transitions - clear old consultation currentQuestion when moving to a new step
            // BUT DO NOT clear the answers - they should persist for display in completed view
            if (backendStep === 'select_package' || backendStep === 'select_package_discovery') {
                // Moving to package selection - clear product details currentQuestion only
                if (flowState.productDetailsData) {
                    flowState.productDetailsData.currentQuestion = null;
                }
                // DO NOT clear flowState.productDetails - answers should persist
            } else if (backendStep === 'select_package_specs') {
                // Moving to package specs - clear package selection data if needed
                // (package selection doesn't have consultation data, so nothing to clear)
            } else if (backendStep === 'fulfillment_specs') {
                // Moving to fulfillment specs - clear package specs question only
                if (flowState.packageSpecsData) {
                    flowState.packageSpecsData.currentQuestion = null;
                }
                // DO NOT clear flowState.packageSpecs - answers should persist
            } else if (backendStep === 'launch_kit') {
                // Moving to launch kit - clear fulfillment specs question only
                if (flowState.fulfillmentSpecsData) {
                    flowState.fulfillmentSpecsData.currentQuestion = null;
                }
                // DO NOT clear flowState.fulfillmentSpecs - answers should persist
            }
            
            if (data.currentQuestion) {
                console.log('[handleResponse] Updating currentQuestion:', data.currentQuestion.id, data.currentQuestion);
                const consultationKey = getCurrentConsultationState(backendStep);
                const dataKey = consultationKey + 'Data';
                if (!flowState[dataKey]) {
                    flowState[dataKey] = {};
                }
                flowState[dataKey].currentQuestion = data.currentQuestion;
                console.log(`[handleResponse] ${dataKey} after update:`, flowState[dataKey]);
                
                // CRITICAL: If we just moved to select_package_specs after product selection,
                // ensure packageData is cleared so we don't show product selection UI
                if (backendStep === 'select_package_specs' && metadata && metadata.type === 'product') {
                    console.log('[handleResponse] Moved to package_specs after product selection - clearing packageData');
                    flowState.packageData = null;
                }
            } else {
                // No currentQuestion means we're in a non-consultation step (like select_package)
                // BUT: For init type, if we're in product_details step, we should have a currentQuestion
                // This handles the case where the first question is returned but currentQuestion isn't set properly
                if (metadata && metadata.type === 'init' && backendStep === 'product_details') {
                    // On init, if we're in product_details but no currentQuestion, 
                    // the backend should have returned one, so this shouldn't happen
                    console.warn('[handleResponse] Init with product_details but no currentQuestion');
                }
                // Make sure we clear any old consultation data
                if (backendStep === 'select_package' || backendStep === 'select_package_discovery') {
                    if (flowState.productDetailsData) {
                        flowState.productDetailsData.currentQuestion = null;
                    }
                }
            }
            if (data.draftOrder) {
                console.log('[handleResponse] Draft order created:', data.draftOrder.id);
                flowState.draftOrder = data.draftOrder;
            }
            
            // Special handling: if backend step is "select_package_variant" but we don't have variants yet
            if (backendStep === 'select_package_variant' && !data.variants && (!flowState.packageData || !flowState.packageData.variants)) {
                console.log('[handleResponse] Backend is in select_package_variant but no variants in response - may need to fetch');
            }
            
            console.log('[handleResponse] Updated flowState:', JSON.parse(JSON.stringify(flowState)));
            console.log('[handleResponse] data.flowState from backend:', data.flowState);
            console.log('[handleResponse] Backend step is:', backendStep);
            
            // Re-render steps
            console.log('[handleResponse] Re-rendering steps...');
            renderSteps();
        }
        
        async function loadAvailableModels() {
            const apiUrl = document.getElementById('apiUrl').value.trim();
            if (!apiUrl) {
                alert('Please enter a Worker URL');
                return;
            }
            
            try {
                const response = await fetch(`${apiUrl}?list=models`);
                const data = await response.json();
                if (data.selected) {
                    alert(`Selected Model: ${data.selected}\n\nAvailable: ${data.models.length} models`);
                }
            } catch (error) {
                alert(`Error: ${error.message}`);
            }
        }
        
        // Initialize - make initial API call to get first question
        async function initializeFlow() {
            console.log('[initializeFlow] Initializing flow...');
            const apiUrl = document.getElementById('apiUrl').value.trim();
            if (!apiUrl) {
                console.log('[initializeFlow] No API URL, skipping initialization');
                renderSteps();
                return;
            }
            
            try {
                // Send empty message to trigger start step
                const response = await fetch(apiUrl, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({ message: '', flow: currentFlow })
                });
                
                if (!response.ok) {
                    console.error('[initializeFlow] Response error:', response.status);
                    renderSteps();
                    return;
                }
                
                const data = await response.json();
                console.log('[initializeFlow] Initial response:', data);
                
                // Use handleResponse to process the initial response properly
                handleResponse(data, { type: 'init' });
            } catch (error) {
                console.error('[initializeFlow] Error:', error);
                renderSteps();
            }
        }
        
        // Initialize
        initializeFlow();
    </script>
</body>
</html>